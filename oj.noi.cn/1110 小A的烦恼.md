|题目名|《小A的烦恼》|  
|---|---|  
|**题源**|CCF中学生计算机程序设计基础篇例6.5|  
|**OJ**|[oj.noi.cn 1110](http://oj.noi.cn/oj/#main/show/1110)|  
|**标签**|模拟，链表|  
|**难度**|普及组简单题|  

#### 题目  

> 世界上有N(N <= 100000)个城市，有M(M <= 500000)条航线。为了使题目不过分复杂，假设：  
>> 任何一个城市都有至少一条航线直飞其他城市；  
>> 每个城市名字都用一个编号代替，任何两个城市之间最多有1条直飞航线，所以"1 2"跟"2 1"是指同一条航线，连接城市1与城市2。  
> 
> 小A是名旅行爱好者，他比较烦恼，因为他手头的航线列表上只有每条航线连接的城市（见输入格式和输入样例），从这张表很难看出每个城市与哪些城市有直飞航线。现在请你帮他解决这个问题。
> 
> 输入格式：  
>> 第一行包含两个整数N（城市数量）和M（航线数量）。  
>> 接下来M行，每行两个整数，描述一条道路连接的两个城市的编号。
>
> 输出格式：  
>> 输出N行，每一行若干个用一个空格隔开的整数。  
>> 第i行输出的是与城市i直接相连的城市编号，保证城市的出现按照道路输入的先后顺序出现。  
>
> 输入样例：  
>> 4 5  
>> 2 3  
>> 3 1  
>> 1 4  
>> 2 4  
>> 1 2  
>> 
> 输出样例：  
>> 3 4 2  
>> 3 4 1  
>> 2 1  
>> 1 2  

#### 分析  

* 如果城市少的话，像输入样例那样，就不需要写程序解决问题了。这道题给出的N和M都很大，就算是画成航线图也无法用肉眼看清每个城市与哪些城市通航，那就要借助程序设计的力量了。  
![](/diagrams/oj.noi.cn%201110%20小A的烦恼2.gif)  
最简单的思路是建立N个长度为N的数组，直接按顺序输入、输出。但是由于N值太大，达到10<sup>5</sup>，N * N的int二维数组需要4 * 10<sup>10</sup> bytes = 37 GB，远远超过了题目的空间限制262144 KB = 256 MB = 0.25 GB。而航线数量M < 500K，远小于N * N，所以这又是稀疏矩阵。  

* 我们之前学过用指针构造动态数组解决此类问题，现在介绍另一种方法：用**数组实现单向链表**，也同样可以节省空间。**总体思路是**：为每个城市建立一个链表，按照输入顺序在链表中记录其所通航的城市。然后输出链表中的每个元素时就是输出其所有通航城市的名单。链表的好处是长度不固定，需要多长就添加到多长，不会浪费空间。以输入样例为例说明：  
	* 4个城市，5条航线  
	* 第一条航线是"2 3"，所以城市2的链表中第一个元素是3，城市3的链表中第一个元素是2；  
	* 第二条航线是"3 1"，所以城市3的链表中第二个元素是1，城市1的链表中第一个元素是3；  
	* 第三条航线是"1 4"，所以城市1的链表中第二个元素是4，城市4的链表中第一个元素是1；  
	* 第四条航线是"2 4"，所以城市2的链表中第二个元素是4，城市4的链表中第二个元素是2；  
	* 第五条航线是"1 2"，所以城市1的链表中第三个元素是2，城市2的链表中第三个元素是1；  
	* 综上，城市1的链表有三个元素3 4 2；城市2的链表有三个元素3 4 1；城市3的链表有两个元素2 1；城市4的链表有两个元素1 2。  

* 具体如何用数组实现这些链表呢？  
	* 每条航线都要在两个链表中各新增一个元素，所以M条航线共增加2 * M个元素。我们建立两个长度为2M的数组存储N个单向链表，空间一点儿都没有浪费。其中第一个数组city[]存储链表元素，第二个数组scsr[]存储后继元素的位置序号  
	* 再建立两个长度为N的数组，输入过程中，第一个数组head[]存储每个城市链表的起始位置，第二个数组temp[]在记录每个城市链表暂时的末位元素所在位置，以此指引计算机依照该位置为各个链表添加新的末位元素  
	* 还是以输入样例为例说明：  
		* 第一条航线"2 3"：
			* city[1]赋值为2，city[2]赋值为3
			* 判断城市2和3的链表是否已建立：  
				* 均为否，建立链表：head[3]赋值为1（城市3的链表从city[1]开始），head[2]赋值为2（城市2的链表从city[2]开始）
			* temp[3]赋值为1（城市3的链表当前末位元素在city[1]），temp[2]赋值为2（城市2的链表当前末位元素在city[2]）  
		* 第二条航线"3 1"：
			* city[3]赋值为3，city[4]赋值为1  
			* 判断城市3和1的链表是否已建立：  
				* 城市1否，建立链表：head[1]赋值为3（城市1的链表从city[3]开始）  
				* 城市2是：scsr[1]赋值为4（在城市3的链表原末位元素city[1]之后添加新末位元素city[4]）  
			* temp[3]改赋值为4（城市3的链表当前末位元素在city[4]），temp[1]赋值为3（城市1的链表当前末位元素在city[3]）  
		* 第三条航线"1 4"  
			* city[5]赋值为1，city[6]赋值为4  
			* 判断城市1和4的链表是否已建立：  
				* 城市4否，建立链表：head[4]赋值为5（城市4的链表从city[5]开始）  
				* 城市1是：scsr[3]赋值为6（在城市1的链表原末位元素city[3]之后添加新末位元素city[6]）
			* temp[4]赋值为5（城市4的链表当前末位元素在city[5]），temp[1]改赋值为6（城市1的链表当前末位元素为city[6]）  
		* 第四条航线"2 4"  
			* city[7]赋值为2，city[8]赋值为4  
			* 判断城市2和4的链表是否已建立：  
				* 均是：scsr[5]赋值为7（在城市4的链表原末位元素city[5]之后添加新末位元素city[7]），scsr[2]赋值为8（在城市2的链表原末位元素city[2]之后添加新末位元素city[8]）  
			* temp[4]改赋值为7（城市4的链表当前末位元素在city[7]），temp[2]改赋值为8（城市2的链表当前末位元素在city[8]）  
		* 第五条航线"1 2"  
			* city[9]赋值为1，city[10]赋值为2  
			* 判断城市1和2的链表是否已建立：  
				* 均是：scsr[6]赋值为9（在城市1的链表原末位元素city[6]之后添加新末位元素city[9]），scsr[8]赋值为10（在城市2的链表原末位元素city[8]之后添加新末位元素city[10]）  
			* temp[1]改赋值为9（城市1的链表当前末位元素在city[9]），temp[2]改赋值为10（城市2的链表当前末位元素在city[10]）  

#### 答案  

